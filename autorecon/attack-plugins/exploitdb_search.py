from autorecon.plugins import ExploitScan
import os
import json
import re
import subprocess

class ExploitDBSearch(ExploitScan):
    """Exploit Database integration plugin for finding and downloading exploits based on discovered services."""

    def __init__(self):
        super().__init__()
        self.name = "Exploit Database Search"
        self.tags = ['exploit', 'exploitdb', 'cve']
        self.risk_level = 'medium'
        self.requires_confirmation = True

    def configure(self):
        self.add_option('searchsploit-path', default='searchsploit', help='Path to searchsploit binary. Default: %(default)s')
        self.add_true_option('download-exploits', help='Download found exploits to local directory')
        self.add_true_option('metasploit-modules', help='Search for Metasploit modules specifically')
        self.add_option('exclude-dos', default='true', help='Exclude DOS exploits. Default: %(default)s')
        self.add_option('platform', help='Filter by platform (windows, linux, etc.)')
        self.add_option('type', help='Filter by exploit type (remote, local, webapps, etc.)')
        
        # Match all services to search for exploits
        self.match_service_name('.*')

    def check(self):
        searchsploit_path = self.get_option('searchsploit_path')
        if not self._command_exists(searchsploit_path):
            self.error(f'searchsploit not found at {searchsploit_path}. Please install exploitdb or update the path.')
            return False
        return True

    def _command_exists(self, command):
        """Check if a command exists in the system PATH."""
        return os.system(f'which {command} > /dev/null 2>&1') == 0

    async def run(self, service):
        searchsploit_path = self.get_option('searchsploit_path')
        
        self.info(f'Searching exploits for {service.service} on {service.target.address}:{service.port}')

        # Create exploits directory
        exploits_dir = os.path.join(service.target.scandir, 'exploits')
        os.makedirs(exploits_dir, exist_ok=True)

        # Search terms based on service
        search_terms = self._generate_search_terms(service)
        
        all_exploits = []
        
        for term in search_terms:
            self.info(f'Searching for exploits related to: {term}')
            exploits = await self._search_exploits(service, term, exploits_dir)
            all_exploits.extend(exploits)

        # Remove duplicates
        unique_exploits = []
        seen_ids = set()
        for exploit in all_exploits:
            if exploit.get('id') not in seen_ids:
                unique_exploits.append(exploit)
                seen_ids.add(exploit.get('id'))

        # Save results
        results_file = os.path.join(exploits_dir, f'{service.protocol}_{service.port}_{service.service}_exploits.json')
        with open(results_file, 'w') as f:
            json.dump(unique_exploits, f, indent=2)

        # Download exploits if enabled
        if self.get_option('download_exploits') and unique_exploits:
            await self._download_exploits(service, unique_exploits, exploits_dir)

        self.info(f'Found {len(unique_exploits)} potential exploits for {service.service}')

        # Create summary file
        summary_file = os.path.join(exploits_dir, f'{service.protocol}_{service.port}_{service.service}_exploit_summary.txt')
        with open(summary_file, 'w') as f:
            f.write(f'Exploit Summary for {service.service} on {service.target.address}:{service.port}\n')
            f.write('=' * 80 + '\n\n')
            
            for exploit in unique_exploits:
                f.write(f"ID: {exploit.get('id', 'Unknown')}\n")
                f.write(f"Title: {exploit.get('title', 'Unknown')}\n")
                f.write(f"Platform: {exploit.get('platform', 'Unknown')}\n")
                f.write(f"Type: {exploit.get('type', 'Unknown')}\n")
                f.write(f"Path: {exploit.get('path', 'Unknown')}\n")
                f.write('-' * 40 + '\n')

    def _generate_search_terms(self, service):
        """Generate search terms based on service information."""
        terms = []
        
        # Basic service name
        terms.append(service.service)
        
        # Service name variations
        service_variations = {
            'http': ['apache', 'nginx', 'iis', 'httpd'],
            'https': ['apache', 'nginx', 'iis', 'httpd', 'ssl', 'tls'],
            'ftp': ['vsftpd', 'proftpd', 'filezilla'],
            'ssh': ['openssh', 'dropbear'],
            'smb': ['samba', 'cifs'],
            'microsoft-ds': ['smb', 'cifs', 'windows'],
            'mysql': ['mysql', 'mariadb'],
            'postgresql': ['postgres', 'postgresql'],
            'mssql': ['sql server', 'mssql'],
            'rdp': ['terminal services', 'remote desktop'],
            'vnc': ['vnc', 'tightvnc', 'realvnc']
        }
        
        if service.service.lower() in service_variations:
            terms.extend(service_variations[service.service.lower()])

        # Port-based searches
        common_port_services = {
            21: ['ftp', 'vsftpd', 'proftpd'],
            22: ['ssh', 'openssh'],
            23: ['telnet'],
            25: ['smtp', 'sendmail', 'postfix'],
            53: ['dns', 'bind'],
            80: ['http', 'apache', 'nginx', 'iis'],
            110: ['pop3'],
            143: ['imap'],
            443: ['https', 'ssl', 'apache', 'nginx', 'iis'],
            445: ['smb', 'cifs', 'windows'],
            993: ['imaps', 'imap ssl'],
            995: ['pop3s', 'pop3 ssl'],
            1433: ['mssql', 'sql server'],
            3306: ['mysql', 'mariadb'],
            3389: ['rdp', 'terminal services'],
            5432: ['postgresql', 'postgres'],
            5900: ['vnc']
        }
        
        if service.port in common_port_services:
            terms.extend(common_port_services[service.port])

        return list(set(terms))  # Remove duplicates

    async def _search_exploits(self, service, search_term, output_dir):
        """Search for exploits using searchsploit."""
        searchsploit_path = self.get_option('searchsploit_path')
        
        # Build searchsploit command
        cmd_parts = [searchsploit_path, '--json']
        
        # Add filters
        if self.get_option('exclude_dos') == 'true':
            cmd_parts.append('--exclude="dos"')
            
        if self.get_option('platform'):
            cmd_parts.append(f'--platform="{self.get_option("platform")}"')
            
        if self.get_option('type'):
            cmd_parts.append(f'--type="{self.get_option("type")}"')

        cmd_parts.append(f'"{search_term}"')
        
        cmd = ' '.join(cmd_parts)
        
        # Execute searchsploit
        output_file = os.path.join(output_dir, f'searchsploit_{search_term.replace(" ", "_")}.json')
        
        try:
            # Run searchsploit and capture output
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            exploits = []
            if result.stdout:
                try:
                    # Parse JSON output
                    data = json.loads(result.stdout)
                    if 'RESULTS_EXPLOIT' in data:
                        exploits = data['RESULTS_EXPLOIT']
                except json.JSONDecodeError:
                    # If JSON parsing fails, try to parse text output
                    exploits = self._parse_text_output(result.stdout)
                
                # Save raw output
                with open(output_file, 'w') as f:
                    f.write(result.stdout)
            
            return exploits
            
        except subprocess.TimeoutExpired:
            self.warn(f'Searchsploit timeout for term: {search_term}')
            return []
        except Exception as e:
            self.error(f'Error running searchsploit for term {search_term}: {e}')
            return []

    def _parse_text_output(self, output):
        """Parse text output from searchsploit when JSON parsing fails."""
        exploits = []
        lines = output.split('\n')
        
        for line in lines:
            # Skip header lines and empty lines
            if not line.strip() or 'Exploit Title' in line or '-' * 20 in line:
                continue
                
            # Parse exploit line
            parts = line.split('|')
            if len(parts) >= 2:
                exploit = {
                    'title': parts[0].strip(),
                    'path': parts[1].strip() if len(parts) > 1 else '',
                    'platform': 'Unknown',
                    'type': 'Unknown',
                    'id': parts[1].strip().split('/')[-1] if len(parts) > 1 else ''
                }
                exploits.append(exploit)
        
        return exploits

    async def _download_exploits(self, service, exploits, output_dir):
        """Download exploits using searchsploit."""
        searchsploit_path = self.get_option('searchsploit_path')
        
        download_dir = os.path.join(output_dir, 'downloaded_exploits')
        os.makedirs(download_dir, exist_ok=True)
        
        for exploit in exploits[:10]:  # Limit to first 10 exploits to avoid overwhelming
            exploit_id = exploit.get('id', '')
            if exploit_id:
                self.info(f'Downloading exploit: {exploit.get("title", "Unknown")}')
                
                cmd = f'{searchsploit_path} -m {exploit_id}'
                await service.execute(f'cd "{download_dir}" && {cmd}')

    def manual(self, service, plugin_was_run):
        if not plugin_was_run:
            service.add_manual_command('Manual Exploit Database searches:', [
                f'# Search for {service.service} exploits',
                f'searchsploit {service.service}',
                f'searchsploit --exclude="dos" {service.service}',
                '',
                f'# Search by port',
                f'searchsploit "port {service.port}"',
                '',
                f'# Platform-specific searches',
                f'searchsploit --platform=windows {service.service}',
                f'searchsploit --platform=linux {service.service}',
                '',
                f'# Type-specific searches',
                f'searchsploit --type=remote {service.service}',
                f'searchsploit --type=webapps {service.service}',
                '',
                f'# Download exploits',
                f'searchsploit -m <exploit_id>',
                '',
                f'# CVE searches',
                f'searchsploit --cve 2023',
                f'searchsploit --cve 2022',
                '',
                f'# Online resources',
                f'# https://www.exploit-db.com/',
                f'# https://cve.mitre.org/',
                f'# https://nvd.nist.gov/',
                f'# https://github.com/nomi-sec/PoC-in-GitHub'
            ])